現在のAIシステムバージョンは「4」です。ゲームバージョン0.2.26以降で動作します。

Lua 5.1.4 を使用。

C++とかで書きたい人は、pap.ZIP を解凍してみてください。

print()関数、及びスクリプトのエラーメッセージは、OutputDebugString()を使用して出力されます。
改行がきちんと出力されるデバッグモニタの使用推奨。（ http://www.vector.co.jp/soft/dl/win95/prog/se046776.html など）

「ai」フォルダに「*.pap」か「*.lua」を入れると、AIとして読み込まれます。
「サンプル」フォルダに、サンプルのAIスクリプトが入っています。

AIのファイル名 ＝ AIの名前になります。（リストに表示される名前です。試合中に表示される名前は別）


ai_init()関数は、レベル選択後に1度呼ばれる関数です。（その都度、AIファイルは再読み込みされます）
ai_main()関数は、組ぷよ出現直後の1フレームだけ呼び出される関数です。（毎フレーム呼び出されるようにも設定可能）
行動が予約されている場合は、おじゃまぷよが発生した場合を除き、ai_main()関数は呼び出されません。

ai_main()関数を毎フレーム呼び出したい場合、ai_SetMainMode(1)を使用してください。


以下関数リファレンス
--------------------------------------------------------------------------------

■ai_SetTumi( x, rot )
	次の1手を決定する。

引数：
	x...横位置（0〜5）
	rot...回転（0〜3）

注意点：
	途中に壁がある場合等、置けない位置をセットした場合は上手く置けない。


■横位置について
ぷよのフィールドは6列なので、左から0,1,2,3,4,5


■回転について
◎...軸ぷよ

 0     1     2     3 
○                   
◎    ◎○  ◎   ○◎
            ○       

つまり、時計回りに0,1,2,3


■ai_GetNow()
	現在の組ぷよを取得。

戻り値：
	{ a, b } a...軸ぷよ  b...子ぷよ
	それぞれ、1...赤  2...黄  3...緑   4...紫   5...青

例：
	now = ai_GetNow()
	print(now.b)
	print(now.a)


■ai_GetNow2( player )
	ai_GetNow() と同じだが、自分と敵、どちらのものを見るかを指定できる。※【0.1.38以降】

引数：
	player:  0...敵  1...自分
	（ai_GetNow2(1) と ai_GetNow() が同等）


■ai_GetScore( x, rot )
	指定した場所に組ぷよを置いた場合に発生する点数と連鎖数を取得。

引数：
	x...横位置（0〜5）※xに-1を指定すると、置かずに計算をする。
	rot...回転（0〜3）※xに-1を指定した場合、現在が何連鎖目として計算するかを指定する（2で2連鎖）

戻り値：
	{ score, rensa, tunagi_a, tunagi_b, x_a, y_a, x_b, y_b, quick } ※【quickのみ0.1.38以降】
	score...点数  rensa...連鎖数  quick...クイックだったら1、違ったら0
	tunagi_a...軸ぷよからいくつ繋がるか  tunagi_b...子ぷよからいくつ繋がるか  
	x_a...軸ぷよだったぷよが設置したX位置  y_a...軸ぷよだったぷよが設置したY位置
	x_b...子ぷよだったぷよが設置したX位置  y_b...子ぷよだったぷよが設置したY位置

	tunagi_a と tunagi_b は、0...置いた場所の周りに同じ色はない（繋がらない）  1...2個くっつく  2...3個くっつく  3...4個くっつく  つまり、3以上だと消える。
	組ぷよが同じ色（赤赤とか）の場合、tunagi_b は0になる。（ちぎらない場合のみ）
	x_a とかの値は、フィールドの左下（1列目の1段目）を0, 0とした座標系。
	置けない場所を指定した場合、scoreは -1 となる。

例：
	a = ai_GetScore( 0, 0 )
	print(a.score)
	print(a.rensa)


■ai_GetScoreE( x, rot )
	ai_GetScore() と同じだが、実際に置いたことにして仮想フィールドを更新する。組ぷよも1つ先のものになる。


■ai_GetScore2( player, x, rot )
	ai_GetScore() と同じだが、自分と敵、どちらのフィールドを見るかを指定できる。※【0.1.38以降】

引数：
	player:  0...敵  1...自分
	（ai_GetScore2(1,x,rot) と ai_GetScore(x,rot) が同等）

戻り値：
	score が -2 で返ってきたときは連鎖中。
	その場合、rensa は現在が何連鎖目なのかの値。


■ai_Reset()
	ai_GetScoreE()、ai_SetNext() 等で変化した状態を元に戻す。


■ai_Save( n )
	ai_GetScoreE()、ai_SetNext() 等で変化した状態をセーブする。

引数：
	n...セーブスロット番号（0〜15）


■ai_Load( n )
	ai_Save() でセーブしたものをロードする。

引数：
	n...セーブスロット番号（0〜15）


■ai_GetNext()
	NEXTぷよを取得。

戻り値：
	ai_GetNow()と同じ形式


■ai_GetNext2( player )
	ai_GetNext() と同じだが、自分と敵、どちらのものを見るかを指定できる。※【0.1.38以降】

引数：
	player:  0...敵  1...自分
	（ai_GetNext2(1) と ai_GetNext() が同等）


■ai_SetNext()
	現在の組ぷよをNEXTぷよのものに変更し、NEXTぷよをネクネクのものに変更する。（置かずに1手進める）


■ai_SetTumiNum( n )
	ai_SetTumi()で何手先まで決定するかを指定する。

引数：
	n...何手セットするか

例：1手目で左から3列目に置き、2手目で左から2列目、3手目で一番左の列に置く。
	ai_SetTumiNum(3)
	ai_SetTumi( 2, 0 )
	ai_SetTumi( 1, 0 )
	ai_SetTumi( 0, 0 )

注意点：
	指定した手数を置き終わるまで ai_main() は呼ばれない。（↑の例だと(0,0)を置き終わるまで）
	ただし、おじゃまぷよが降ってきた場合は即座に ai_main() が呼ばれる。


■ai_GetSpace( player )
	6x12のフィールドに、いくつ空きがあるかを取得する。

引数：
	player:  0...敵  1...自分

戻り値：
	空き数

例：自分（AI）のフィールドの空き数を調べる。
	myspace = ai_GetSpace(1)


■ai_GetField( player )
	現在のフィールド状況を取得する。

引数：
	player:  0...敵  1...自分

戻り値：
	6x18個の配列（ 6列x(12段+画面外6段) ） ※Luaの配列のインデックスは1から開始されます（0ではない）
	それぞれ、0...空き  1...赤  2...黄  3...緑   4...紫   5...青  6...おじゃまぷよ

例：自分側、下2段のフィールドをデバッグ出力する
	--------1----2----3----4----5----6---
	col = {"赤","黄","緑","紫","青","◎"}  -- ここはcol[1]〜col[6]
	col[0] = "□"  -- ※こうすればcol[0]として使える

	f = ai_GetField(1)

	str1 = col[f[7]]..col[f[8]]..col[f[9]]..col[f[10]]..col[f[11]]..col[f[12]]
	str0 = col[f[1]]..col[f[2]]..col[f[3]]..col[f[ 4]]..col[f[ 5]]..col[f[ 6]]
	print(str1.."\n"..str0)


■ai_SetField( player, field )
	仮想フィールドを指定した6x18個の配列に置き換える。※【0.1.38以降】
	配列のフォーマットはai_GetField()のものと同じ。
	ai_init()関数内で使用すると、1P、2P両方のフィールドを指定したものに「実際に」変更する。
	ただし、ai_init()関数内での使用はネット対戦時は無効。

引数：
	player:  0...敵  1...自分
	field...6x18個の配列


■ai_GetCount()
	現在何手目かを取得。

戻り値：
	現在何手目かの値。1手目だと1。


■ai_GetCount2( player )
	ai_GetCount() と同じだが、自分と敵、どちらのものを見るかを指定できる。※【0.1.38以降】

引数：
	player:  0...敵  1...自分
	（ai_GetCount2(1) と ai_GetCount() が同等）


■ai_SetTable( type, reverse, tbl )
	配ぷよテーブルをセット。  ※ai_init()関数内でのみ有効。

引数：
	tbl...文字列でrygpbがそれぞれ赤黄緑紫青に対応（256組まで指定可能。rygpb以外の文字は無視される）
	reverse:  0...軸ぷよ、子ぷよの順に記述  1...子ぷよ、軸ぷよの順に記述
	type:  0...余った部分をランダムで埋める  1...指定した配ぷよを繰り返す

例1：赤黄 紫紫 赤緑 赤紫 赤黄 紫紫 …… という配ぷよにする。
	ai_SetTable( 1, 0, "RYPPRGRP" )

例2：赤黄 紫紫 赤緑 赤紫 赤黄 紫紫 …… という配ぷよにする。（例1と同じ）
	ai_SetTable( 1, 1, "yr pp gr pr" )


■ai_SetDefSpeed( speed )
	AIの基本速度を設定。  ※ai_init()関数内でのみ有効。「基本速度」の設定であり、実際に速度を変更できるわけではない。

引数：
	speed...基本速度（遅い 0〜9 速い）


■ai_SetName( name )
	AIの名前（対戦時の表示名）を設定。  ※ai_init()関数内での使用を推奨。【0.0.96以降】

引数：
	name...名前。半角英数で指定する

例：CPUの表示名を「HARUKA」にする。
	ai_SetName("HARUKA")


■ai_GetBattleCount()
	現在何試合目かを取得。

戻り値：
	現在何試合目かの値。1試合目だと1。


■ai_GetMemory() ※現状Luaから呼ばれることは想定していません。
	グローバルメモリアドレスを取得。グローバルメモリは、AIの読み直しが行われても初期化されません。

戻り値：
	グローバルメモリ（1024バイト）の先頭アドレスを取得。


■ai_SetMainMode( mode )
	ai_main()の呼ばれ方を設定。【0.0.96以降】

引数：
	mode:  0...通常  1...ai_main()は毎フレーム呼ばれる


■ai_SetBMainMode( mode )
	ai_bmain()の呼ばれ方を設定。【0.2.26以降】
	ai_bmain()は、AIが組ぷよの操作等を行えない時も含めて必ず毎フレーム呼ばれます。

引数：
	mode:  0...ai_bmain()は呼ばれない  1...ai_bmain()は毎フレーム呼ばれる


■ai_GetPlayerMode( player )
	現在のプレイヤーモードを取得。【0.2.26以降】

引数：
	player:  0...敵  1...自分

戻り値：
	 1: 組ぷよ操作中（操作可能なのはここだけ）
	 2: 空中設置ぷよの落下（通常は使われない）
	 3: ぷよが消えるかチェック中（連鎖中にも一瞬入る）
	 4: 連鎖中
	 5: WAIT
	 6: WAIT
	 7: おじゃまぷよが降ってきている
	 8: LOSE or DRAW
	 9: WIN
	10: レベル選択画面
	11: 開始までの間
	12: WAIT
	13: WAIT
	14: なぞぷよで失敗後
	15: なぞぷよで成功後
	16: レベル選択に戻る


■ai_GetTotalScore( player )
	プレイヤーのスコアを取得。【0.2.26以降】

引数：
	player:  0...敵  1...自分

戻り値：
	スコア。


■ai_IsTumiReserved()
	次の手が予約されているかどうかをチェック。【0.0.96以降】

戻り値：
	次の手が予約されている場合は1。されていない場合は0。
	ai_SetTumi()でセットした手が完了した場合も0。
	おじゃまぷよが降ってきた直後も0。


■ai_GetConnectInfo( player, a, b )
	現在の仮想フィールドの連結情報を取得する。【0.1.38以降】

引数：
	player:  0...敵  1...自分
	a, b ...a連結以上b連結以下のものが列挙対象となる。bに-1を指定すると、a連結以上のものが全て列挙される

戻り値：
	{ num, connect[], color[], lx[], rx[], dy[], uy[] }
	num...いくつ列挙されたか
	connect[n]...連結数  color[n]...色  ※n:1〜num
	lx[n]...左側のX座標  rx[n]...右側のX座標
	dy[n]...下側のY座標  uy[n]...上側のY座標


■ai_Delete( player, x, y )
	仮想フィールドを、指定した位置のぷよ（とそこに繋がってるぷよ）を消した状態に更新する。【0.1.38以降】

引数：
	player:  0...敵  1...自分
	x...消す位置のX座標(0〜5)  y...消す位置のY座標(0〜11) 

例：デスタワーのカギを消した後、何点入るかを計算する。
	ai_Delete( 1, 3, 0 ) -- 自分側(3,0)の位置にあるカギを消す
	sc = ai_GetScore( -1, 2 ) -- その状態を2連鎖目として点数計算


■ai_SetPad( up, right, down, left, a, b )
	AIのパッド操作を指定する。【0.1.38以降】
	操作を指定した場合、ai_SetTumi()等は動作しない。

引数：
	up   :0...レバー上off  1...レバー上on  -1...パッド操作をデフォルトのものに戻す
	right:0...レバー右off  1...レバー右on
	down :0...レバー下off  1...レバー下on
	left :0...レバー左off  1...レバー左on
	a:0...左回転ボタンoff  1...左回転ボタンon
	b:0...右回転ボタンoff  1...右回転ボタンon


■ai_GetSettingSpeed()
	AIに設定されている現在の速度設定を取得。【0.1.38以降】

戻り値：
	0〜9:おそい〜はやい  10:フルスピード  11〜14:限界突破1〜4
	10以降は隠し。レバー下押しで高速落下。バグる場合もあるので非保証。


■ai_GetSettingMawasi()
	AIに設定されている現在のまわし設定を取得。【0.1.38以降】

戻り値：
	0...まわしOFF  1...まわしON


■ai_GetSettingGiveup()
	ギブアップ設定が有効かどうかを取得。【0.1.38以降】

戻り値：
	0...ギブアップ操作無効  1...ギブアップ操作有効


■ai_GetDropSpeed( player )
	ぷよの自動落下する速度を取得。【0.1.38以降】

戻り値：
	1マス自由落下するのに掛かるフレーム数。
	速度設定が10以上のものに関してはこの数字と一致しない。※ai_GetSettingSpeed()の説明を参照。


■ai_GetYokokuOjama( player )
	予告されているおじゃまぷよの数を取得。【0.1.38以降】

引数：
	player:  0...敵  1...自分

戻り値：
	予告されているおじゃまぷよの数。


■ai_GetNowPos( player )
	組ぷよ（軸ぷよ）の現在の位置を取得。※【0.1.38以降】
	ついでに回転も取得。

引数：
	player:  0...敵  1...自分

戻り値：
	x...0.0〜5.0
	y...0.0〜11.5
	rot...0〜3





■AIバージョンとゲームバージョンの対応について
・AIシステムバージョン「4」0.2.26 以降
・AIシステムバージョン「3」0.1.38 以降
・AIシステムバージョン「2」0.0.96 以降

